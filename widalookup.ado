// Drop the program from memory if already loadedcap prog drop widalookup// Defines the programprog def widalookup	// Minimum version of Stata required to run the program	version 14.1 		// Syntax used to call the program	syntax [using] [, DSn(passthru) SCHema(string asis) EXPort(string) 		 ///   	EOpts(string asis) SAve(string) REPlace ]	// Use the database owner schema by default if not specified	if `"`dsn'"' != "" & `"`schema'"' == "" loc schema dbo	// If using is passed import the data else assume loaded in memory already	if `"`using'"' != "" import delimited `using', varn(1) clear case(l)		// Defines a set of local macros used to for abbreviations when constructing	// SQL Syntax for building and loading tables	loc ct CREATE TABLE	loc dom `schema'.ACCESS_DOMAINS	loc pctlab `schema'.ACCESS_PCTILE_LABELS	loc pctband `schema'.ACCESS_PERCENTILE_BANDS	loc ti TINYINT 	loc nn NOT NULL	loc si SMALLINT	loc vc VARCHAR	loc ins INSERT INTO 	loc val VALUES 	loc pk PRIMARY KEY 	loc fk REFERENCES 	loc casc ON UPDATE CASCADE	loc noact	loc ckdrop IF OBJECT_ID	loc inn IS NOT NULL	loc dt DROP TABLE 	// Rename variables in source file	rename (py_school_year school_year_growth_name test_area_name 			 ///   	py_proficiency_level scale_score_growth ptile py_grade_level)(pschyr 	 ///   	schyrlab dom minplev diff pctileband mingrade)	// Remove all but the minimum grade level	qui: replace mingrade = "9" if mingrade == "9-12"	// Recast as numeric values	qui: destring mingrade, replace	// Create maxgrade variable to accommodate the range values at the high school 	qui: g byte maxgrade = cond(mingrade != 9, mingrade, 12)	// Pull the academic year ending value from the school year label	qui: g cschyr = real(substr(schyrlab, -4, 4))	// Create a numeric version of the domain variable	qui: g byte domain = cond(dom == "Overall", 1, 							 ///   						 cond(dom == "Comprehension", 2,					 ///    						 cond(dom == "Listening", 3,						 ///   						 cond(dom == "Literacy", 4, 						 ///   						 cond(dom == "Oral", 5,								 ///   						 cond(dom == "Reading", 6, 							 ///   						 cond(dom == "Speaking", 7, 8))))))) 	// Defines value labels for the domain variable	la def domain 	1 "Overall" 2 "Comprehension" 3 "Listening" 4 "Literacy" ///   					5 "Oral" 6 "Reading" 7 "Speaking" 8 "Writing", modify					// Applies value labels to the domain variable				la val domain domain				// Drops variables that are nolonger needed	qui: drop location_name schyrlab dom	// Removes the th suffix and prefixes values with the string pct	qui: replace pctileband = "pct" + subinstr(pctileband, "th", "", .)	// Restructures the data (e.g., 1 variable per threshold)	qui: reshape wide diff, i(pschyr mingrade minplev domain) j(pctileband) string	// Summarize the 20th %ile threshold 	qui: su diffpct20 	// Store the minimum value in a local macro	loc min = r(min)	// Store the maximum value in a local macro	loc max = r(max)	// Loop over the other threshold variables	foreach v of var diffpct40 diffpct60 diffpct80 {		// Get summary statistics for the variable		qui: su `v'				// If the minimum value for this variable is less than the value in the 		// min local macro replace the minimum with this value		if r(min) < `min' loc min = r(min)				// Do the samething but apply the logic to maximum values		if r(max) > `max' loc max = r(max)			} // End Loop over threshold variables	// Create a minimum value for the 1-20th %ile based on the minimum observed 	// difference and a small buffer	qui: g mindiff20 = `min' - 1	// Do the same for the 81st-99th %ile with the same sized buffer	qui: g maxdiff100 = `max' + 1	// Set the floors for the thresholds based on the next integer above the 	// ceiling from the previous threshold	qui: g mindiff40 = diffpct20 + 1	qui: g mindiff60 = diffpct40 + 1	qui: g mindiff80 = diffpct60 + 1	qui: g mindiff100 = diffpct80 + 1	// Rename the variables that start with diffpct to start with maxdiff	rename diffpct* maxdiff*	// Normalize the data again	qui: reshape long mindiff maxdiff, i(pschyr mingrade minplev domain) j(pctileband)	// Use smaller integer values for the percentile band indicators	qui: replace pctileband = cond(pctileband == 20, 0, cond(pctileband == 40, 1,  ///   						 cond(pctileband == 60, 2, cond(pctileband == 80, 3, 4))))	// Define value labels for the percentile bands							la def pctileband 0 "1st-20th %ile" 1 "21st-40th %ile" 2 "41st-60th %ile" ///   						3 "61st-80th %ile" 4 "81st-99th %ile", modify	// Apply the value labels to the percentile band variable						la val pctileband pctileband						// Create the maximum value for the proficiency level ranges	qui: g maxplev = min(minplev + 0.4, 6)	// Set the display order of the variables	order pschyr cschyr mingrade maxgrade domain minplev maxplev mindiff 	 ///   	maxdiff pctileband	// Make sure the minimum difference is at most equal to the maximum	qui: replace mindiff = maxdiff if mindiff > maxdiff	// Optimize the data storage	qui: compress	// Tag duplicate observations	qui: duplicates tag pschyr mingrade domain minplev mindiff, gen(dup)	// Create a secondary label in case MLD wants to change business rules in the 	// future to use the lower of the two labels when there is a tie based on the 	// difference score and prior proficiency level	qui: bys pschyr mingrade domain minplev mindiff (pctileband): 			 ///   	g byte lowpctileband = cond(dup == 1, pctileband[_n - 1], pctileband)	// Drop the "duplicate" records	qui: drop if mi(lowpctileband)	// Drop the duplicate indicator	drop dup	// Copy value labels	la copy pctileband lowpctileband	// Apply copied value labels	la val lowpctileband lowpctileband	// Define variable labels for the variables	la var pschyr "Prior School Year (Ending)"	la var cschyr "Current School Year (Ending)"	la var mingrade "The minimum grade span for which the record can be attributed"	la var maxgrade "The maximum grade span for which the record can be attributed"	la var domain "The WIDA ACCESS content domain"	la var minplev "The minimum proficiency level in the domain from the prior school year"	la var maxplev "The maximum proficiency level in the domain from the prior school year"	la var mindiff "The smallest scaled score difference for this classification"	la var maxdiff "The largest scaled score difference for this classification"	la var pctileband "The percentile growth band based on the conditional factors"	la var lowpctileband "Minimum percentile growth band when two or more values possible"	// Defines dataset characteristics that persist with the file in case users 	// want to load the data at a different point in time.  These references 	// get used to generate the SQL that builds the lookup tables, creates 	// foreign key constraints, and loads the data into the table for the lookup 	// function	char _dta[pschyr] pschyr `si' `nn'	char _dta[cschyr] cschyr `si' `nn'	char _dta[mingrade] mingrade `ti' `nn'	char _dta[maxgrade] maxgrade `ti' `nn'	char _dta[domain] domain `ti' `fk' `dom'(domain) `casc'	char _dta[minplev] minplev DECIMAL(2, 1) `nn'	char _dta[maxplev] maxplev DECIMAL(2, 1) `nn'	char _dta[mindiff] mindiff INT `nn'	char _dta[maxdiff] maxdiff INT `nn'	char _dta[pctileband] pctileband `ti' `fk' `pctlab'(pctileband) `casc'	char _dta[lowpctileband] lowpctileband `ti' `fk' `pctlab'(pctileband)	char _dta[pk] CONSTRAINT pk_pctile_band_table `pk' (pschyr, mingrade, domain, minplev, mindiff)	// Check the export option	if !mi(`"`export'"') {			// Check if file extension is csv		if substr(`"`export'"', -3, 3) == "csv" {					// Export the file as delimited text			qui: export delimited using `"`export'"', `replace' `eopts' delim(",")					} // End IF Block				// Check for tsv extension		else if inlist(substr(`"`export'"', -3, 3), "tsv", "tab") == 1 {					// Export the file as delimited text			qui: export delimited using `"`export'"', `replace' `eopts' delim("\t")					} // End ELSEIF Block			// Check for MS Excel extensions		else if inlist(substr(`"`export'"', -3, 3), "xls", "lsx") == 1 {					// Export the file as delimited text			qui: export excel using `"`export'"', `replace' `eopts'					} // End ELSEIF Block			// Otherwise		else {						// Print error message to console			di as err `"Unrecognized file extension `= substr(`"`export'"', -3, 3)'"'				// Print letting them know no file was saved			di as res "No file saved."					} // End ELSE Block			} // End IF Block for exporting the dataset	// Check save option	if `"`save'"' != "" qui: save `"`save'"', `replace'		// Check for db option	if `"`dsn'"' != "" {			// Drop the ACCESS_PERCENTILE_BANDS table if it already exists				 		odbc exec("`ckdrop'('`pctband'', 'U') `inn' `dt' `pctband'"), `dsn'		// Drop the ACCESS_DOMAINS table if it already exists				 		odbc exec("`ckdrop'('`dom'', 'U') `inn' `dt' `dom'"), `dsn'		// Drop the ACCESS_PCTILE_LABELS table if it already exists				 		odbc exec("`ckdrop'('`pctlab'', 'U') `inn' `dt' `pctlab'"), `dsn'				// Create a table to store the domain numeric values and labels		odbc exec("`ct' `dom'(domain `ti' `pk', label `vc'(13) `nn')"), `dsn'		// Defines the table that will store the Percentile growth band labels		odbc exec("`ct' `pctlab'(pctileband `ti' `pk', label `vc'(14) `nn')"), `dsn'		// Call insert builder to get the values for domain into format for 		// inserting into a table		insertbuilder domain				// Populate the table with the numeric codes and the labels		odbc exec("`ins' `dom' `val' `r(insert)'"), `dsn'				// Call insert builder to get the values for pctileband into format for 		// inserting into a table		insertbuilder pctileband		// Populates the table with the numeric values and the labels		odbc exec("`ins' `pctlab' `val' `r(insert)'"), `dsn'				// Calls the table builder subroutine		tablebuilder, tname(`pctband')				// Defines the table that will store the lookup data		odbc exec("`r(table)'"), `dsn'		// Load the data into the lookup table		odbc ins, t("`pctband'") `dsn'		// Get all of the variables in the dataset		qui: ds		// Persist the variable names in a new macro		loc vars `r(varlist)'		// Adds the meta data to the table		foreach v in `vars' {					// Build out the stored procedure calls to add the metadata 			loc stub1 "EXEC sp_addextendedproperty 'Comment', '`: var l `v''', 'SCHEMA',"						// Adds the schema, table, and variable name information			loc stub2 "'`schema'', 'TABLE', 'ACCESS_PERCENTILE_BANDS', 'COLUMN', '`v''"						// Stores the full call in a new macro			odbc exec("`stub1' `stub2'"), `dsn'					} // End Loop over the variables				} // End case for handling database pushes// Ends definition of main command	end// Defines an rclass subroutine to construct a string of inserted values for // building SQL Lookup tables from value labelsprog def insertbuilder, rclass	// Syntax used to call the sub routine	syntax varname(num)		// Get the values for domains	qui: levelsof `varlist', loc(d)	// Loop over the domain labels	foreach j of loc d {		// On first iteration construct the first value to insert		if `"`dval'"' == "" loc dval (`j', '`: lab (`varlist') `j''')				// On subsequent iterations add to the syntax		else loc dval `dval', (`j', '`: lab (`varlist') `j''')			} // End of Loop over domain values	// Returns the constructed values to insert	ret loc insert `dval'// End of the subroutine	end// Defines subroutine used to construct the SQL used to build the table definitionprog def tablebuilder, rclass 	// Syntax for the subroutine	syntax, TNAme(string asis)	// Opening code to create the ACCESS_PERCENTILE_BANDS table	loc buildtable CREATE TABLE `tname'(	qui: ds		// Adds the meta data to the table	foreach v in `r(varlist)' { 		// Creates the syntax to build the ACCESS_PERCENTILE_BANDS table		loc buildtable `buildtable' `: char _dta[`v']',				} // End Loop over variables in the file 		// Adds the primary key constraint to the table and closing parentheses	loc buildtable `buildtable' `: char _dta[pk]')			// Return the SQL to construct the table	ret loc table `buildtable'	// End the subroutine definitionend	